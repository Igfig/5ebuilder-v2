{"version":3,"sources":["app/initialize.js","app/js/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"..\\js\\app.js","sourcesContent":["document.addEventListener('DOMContentLoaded', function() {\r\n  // do your setup here\r\n});\r\n","/* TODO: find a better way to refer to Con mod than \"monster.abilities[2].mod\"\r\n * Ideally, should be able to refer to it by name\r\n * \r\n * I think we might actually want to go back to storing a lot of these as \r\n * objects instead of arrays, actually. The orders matter only in one place, \r\n * and the elements of the collection don't actually change.\r\n * \r\n * The thing to do would be to have the objects, and then have an object \r\n * somewhere called Orderings, which contains array orderings for all the \r\n * various objects out there.\r\n * Or possibly: actually implement an ordered-dict sort of object.\r\n * Or maybe: write a function that turns an object into an array sorted \r\n * according to some property of each of the object's values.\r\n * \r\n * Probably the first of these. It's the least prone to screwing up.\r\n */\r\n\r\n\r\nvar app = angular.module(\"monsterBuilder\", []);\r\napp.controller(\"monsterController\", function($scope, $http, $filter) {\r\n\t\r\n\t/* load variables from JSON */\r\n\t$http.get(\"js/lists.json\").then(function(lists){\r\n\t\tfor (list in lists.data){\r\n\t\t\t$scope[list] = lists.data[list];\r\n\t\t}\r\n\t\t\r\n\t\t/* initialize dependent variables */\r\n\t\t$scope.monster.size = getFromArray($scope.SIZES, 'Medium');\r\n\t\t\t//$filter('filter')($scope.SIZES, {name:'Medium'})[0];\r\n\t\t//$scope.monster.speed.ground = $scope.monster.size.speed;\r\n\t\t\r\n\t\t// bind ability scores to mods (and save bonuses?)\r\n\t\tfor (var ability in $scope.monster.abilities) {\r\n\t\t\tbindModToAbility($scope.monster.abilities[ability]);\r\n\t\t}\r\n\t\t\r\n\t\t// calculate monster hp\r\n\t\t$scope.$watchGroup([\"monster.size.hd\", \"monster.hd\", \"monster.abilities[2].mod\"],\r\n\t\t\t\tfunction() {\r\n\t\t\t$scope.monster.hp = diceAverage($scope.monster.hd, \r\n\t\t\t\t\t$scope.monster.size.hd, getAbility('Con').mod);\r\n\t\t\t\r\n\t\t\tif ($scope.builder.hdMode == \"fixed\") {\r\n\t\t\t\t//set target hp to current hp\r\n\t\t\t\t$scope.builder.hpTarget = $scope.monster.hp;\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t// bind target hp to HD\r\n\t\t$scope.$watch(\"builder.hpTarget\", function() {\r\n\t\t\tif ($scope.builder.hdMode == \"dynamic\") {\r\n\t\t\t\t$scope.monster.hd = getNumDiceFromAverage($scope.builder.hpTarget, \r\n\t\t\t\t\t\t$scope.monster.size.hd, getAbility('Con').mod);\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t// functions dependent on loaded variables\r\n\t\t\r\n\t\t$scope.newAttack = function() {\r\n\t\t\tvar attack = $scope.builder.defaultAttack;\r\n\t\t\t$scope.monster.attacks.push(attack);\r\n\t\t\tbindTotalDamageToAttack(attack);\r\n\t\t}\r\n\t\t\r\n\t\t$scope.goToTab = function(tab) {\r\n\t\t\t$scope.builder.tab = tab;\r\n\t\t}\r\n\t});\r\n\r\n\t\r\n\t\r\n\t/* PRIVATE FUNCTIONS */\r\n\t\r\n\t\r\n\tfunction expressionFromObject(objectName) { //TODO: change name\r\n\t\treturn $scope[objectName]; //no, gotta split this on dots\r\n\t}\r\n\t\r\n\t\r\n\t/* binds an ability's mod to its base score */\r\n\tfunction bindModToAbility(ability) {\r\n\t\t$scope.$watch(function(){\r\n\t\t\treturn ability.score;\r\n\t\t}, function(){\r\n\t\t\tability.mod = Math.floor((ability.score - 10) / 2);\r\n\t\t});\r\n\t}\r\n\t\r\n\t//old, messy version of ability binding\r\n\t/*function bindModToAbility(ability) {\r\n\t\t$scope.$watch(\"abilities['\" + ability + \"'].score\", function(score) {\r\n\t\t\t$scope.abilities[ability].mod = Math.floor((score - 10) / 2);\r\n\t\t});\r\n\t}*/\r\n\t\r\n\tfunction bindTotalDamageToAttack(attack) {\r\n\t\t$scope.$watchGroup(function(){\r\n\t\t\tconsole.log([attack.damage.dice.num, attack.damage.dice.size, \"monster.abilities[0].mod\"]);\r\n\t\t\treturn [attack.damage.dice.num, attack.damage.dice.size, \"monster.abilities[0].mod\"];\r\n\t\t\t\r\n\t\t}, function(){\r\n\t\t\tattack.damage.total = diceAverage(attack.damage.dice.num, attack.damage.dice.size);\r\n\t\t});\r\n\t}\r\n\t\r\n\tfunction diceAverage(num, size, bonus) {\r\n\t\tbonus = bonus || 0;\r\n\t\treturn Math.floor(num * ((size + 1) / 2 + bonus));\r\n\t}\r\n\t\r\n\tfunction getNumDiceFromAverage(average, size, bonus) {\r\n\t\tbonus = bonus || 0;\r\n\t\treturn Math.round(average / ((size + 1) / 2 + bonus));\r\n\t}\r\n\t\r\n\tfunction getFromArray(array, value) {\r\n\t\ttry {\r\n\t\t\treturn $filter('filter')(array, {id: value})[0];\r\n\t\t} catch (err) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction getAbility(ability) {\r\n\t\t//console.log(getFromArray($scope.monster.abilities, ability));\r\n\t\tconsole.log($scope.monster.abilities);\r\n\t\treturn getFromArray($scope.monster.abilities, ability);\r\n\t}\r\n});\r\n"]}